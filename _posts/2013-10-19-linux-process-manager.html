---
layout: post
title: Linux下实现通过一个进程控制另一个进程的启动、停止、崩溃重启
tags: [Linux,Process]
---
create_process函数用于进行进程的启动。这里仅给出了带有简单命令行参数或者不带参数的进程的例子。如果需要启动命令行参数复杂的进程，请使用man exec查找execl的其他替代调用方法。<br>
<!--break-->
<br>kill_process用于停止进程。kill掉的进程因为是这个程序的子进程，所以不作任何处理的话，会变成僵尸进程。因此，加入了对信号SIGCHLD的监控。其中的wait函数的作用是接收子进程的状态。我们的进程中接收了这个状态，linux系统就认为我们已经了解了子进程状态，就不会再子进程意外结束的时候把它变成僵尸进程了。<br><br>judge_proc_exist函数通过查询/proc路径下的ProcID来确认进程是否依然存在。如果子进程变成了僵尸进程，则它的ProcID依然会留在这里，所以无法通过这种方式判断是否进程意外退出了。<br><br>daemon_thread线程用于监控子进程是否异常退出，如果是则重启。<br><br>其实也可以不用这么麻烦，直接在sig_chld中重启子进程也是可以的。这样的话，judge_proc_exist和daemon_thread斗不需要了。<br><br><br><pre class="brush: c; gutter: true; first-line: 1; highlight: []; html-script: false"><br>/*<br>    gcc daemon.c -pthread<br>*/<br><br><br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;errno.h&gt;<br>#include &lt;dirent.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;signal.h&gt;<br><br>#include &lt;pthread.h&gt;<br><br>#ifndef TRUE<br>#define TRUE (!0)<br>#endif<br><br>#ifndef FALSE<br>#define FALSE 0<br>#endif<br><br>typedef int bool;<br><br>char glb_process[1024] = &quot;&quot;;<br>char glb_arg[1024] = &quot;&quot;;<br><br>int glb_pid = -1;<br>bool daemon_thread_running = FALSE;<br><br>int create_process(const char* cmd, const char* arg)<br>{<br>    int pid = fork();<br>    if(pid == -1)<br>    {<br>        printf(&quot;fork error\\n&quot;);<br>        return -1;<br>    }<br>    else if(pid == 0){<br>        int ret = execl(cmd, arg, NULL);<br>        if(ret &lt; 0)<br>        {<br>            printf(&quot;execl : %s(%d)\\n&quot;, sys_errlist[errno], errno);<br>            return -2;<br>        }<br>        else{<br>        }<br>    }<br>    else{<br>    }<br><br>    return pid;<br>}<br><br>int kill_process(int pid)<br>{<br>    int ret = kill(pid, SIGKILL);<br>    if(ret &lt; 0)<br>    {<br>        printf(&quot;kill : %s(%d)\\n&quot;, sys_errlist[errno], errno);<br>        return -1;<br>    }<br>    return 0;<br>}<br><br>bool judge_proc_exist(int pid)<br>{<br>    DIR* dir;<br>    struct dirent* s_dir;<br>    struct stat file_stat;<br>    const char *proc_dir = &quot;/proc/&quot;;<br>    char s_pid[10] = &quot;&quot;;<br><br>    if((dir = opendir(proc_dir)) == NULL) {<br>        printf(&quot;open %s error : %s(%d)&quot;, proc_dir, sys_errlist[errno], errno);<br>        return TRUE;<br>    }<br>    sprintf(s_pid, &quot;%d&quot;, pid);<br><br>    bool found = FALSE;<br>    while((s_dir = readdir(dir)) != NULL) {<br>        lstat(s_dir-&gt;d_name, &amp;file_stat);<br>        if((!strcmp(s_pid, s_dir-&gt;d_name)) &amp;&amp; (S_ISDIR(file_stat.st_mode))){<br>            found = TRUE;<br>            break;<br>        }<br>    }<br>    <br>    closedir(dir);<br>    <br>    return found;<br>}<br><br>void* daemon_thread(void* user_data )<br>{<br>    char input[ 256 ];<br>    while(1){<br>        if(daemon_thread_running &amp;&amp; (glb_pid != -1)){<br>            if(!judge_proc_exist(glb_pid)){<br>                glb_pid = create_process(glb_process, glb_arg);<br>                printf(&quot;process(%d) restarted...\\n&quot;, glb_pid);<br>            }<br>            usleep(100);<br>        }<br>    }<br>    return 0;    <br>}<br><br>void* input_thread(void* user_data )<br>{<br>    char input[ 256 ];<br>    while(1){<br>        if( gets(input) != NULL){<br>            if(input[0] == &#039;s&#039;){<br>                glb_pid = create_process(glb_process, glb_arg);<br>                printf(&quot;process(%d) started...\\n&quot;, glb_pid);<br>            }<br>            else if(input[0] == &#039;k&#039;){<br>                kill_process(glb_pid);<br>                printf(&quot;process(%d) killed...\\n&quot;, glb_pid);<br>            }<br>            else if(input[0] == &#039;q&#039;){<br>                exit(0);<br>            }<br>            else if(input[0] == &#039;d&#039;){<br>                daemon_thread_running = !daemon_thread_running;<br>                printf(&quot;daemon_thread_running(%s)\\n&quot;, daemon_thread_running?&quot;TRUE&quot;:&quot;FALSE&quot;);<br>            }<br>            else if( input[0] == &#039;h&#039; ){<br>                printf(&quot;s -- start the process\\n&quot;);<br>                printf(&quot;k -- kill the process\\n&quot;);<br>                printf(&quot;d -- switch daemon process\\n&quot;);<br>                printf(&quot;press &#039;q&#039; to end this program \\n&quot; );<br>                <br>            }<br>        }<br>    }<br>    return 0;    <br>}<br><br>void sig_chld( int signo ) {<br>    pid_t pid;<br>    int stat;<br>    pid = wait(&amp;stat);    <br>    printf( &quot;child %d exit\\n&quot;, pid );<br>    return;<br>}<br>int main(int argc, char* argv[])<br>{<br>    pthread_t it;<br>    pthread_t dt;<br>    if(argc &lt; 2){<br>        printf(&quot;Usage : %s &lt;full path and file name&gt; [arg]\\n&quot;, argv[0]);<br>        printf(&quot;build at %s %s\\n&quot;, __DATE__, __TIME__);<br>        return -1;<br>    }<br>    <br>    if(argc &gt; 1){<br>        strcpy(glb_process, argv[1]);<br>    }<br>    if(argc &gt; 2){<br>        strcpy(glb_arg, argv[2]);<br>    }<br>    <br>    printf(&quot;h-- help\\n&quot;);<br>    <br>    signal(SIGCHLD,  &amp;sig_chld);<br><br>    pthread_create(&amp;it, NULL, input_thread, NULL );<br>    pthread_create(&amp;dt, NULL, daemon_thread, NULL );<br><br>    while(1);<br>}<br><br></pre>